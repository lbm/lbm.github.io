{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/blog/using-wildcard-certificates-with-traefik-and-k3s","result":{"data":{"post":{"slug":"/blog/using-wildcard-certificates-with-traefik-and-k3s","title":"Using Wildcard Certificates with Traefik and K3s","date":"Mar 27th 2021","tags":[{"name":"Kubernetes","slug":"kubernetes"},{"name":"Tutorials","slug":"tutorials"}],"description":null,"canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Using Wildcard Certificates with Traefik and K3s\",\n  \"date\": \"2021-03-27T00:00:00.000Z\",\n  \"tags\": [\"Kubernetes\", \"Tutorials\"],\n  \"banner\": \"./using-wildcard-certificates-with-traefik-and-k3s.jpg\",\n  \"slug\": \"/using-wildcard-certificates-with-traefik-and-k3s\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://k3s.io/\"\n  }, \"K3s\"), \" is a lightweight Kubernetes distribution built for the purposes of IoT and Edge computing. Recently, I decided to use it as the basis for all my self-hosted services. My goal was to set up a Kubernetes distribution that would run well across a bunch of ARM64 compute modules. As is standard for me, I decided to over-engineer it and ensure that my home network was as \\\"enterprisey\\\" as humanely possible.\"), mdx(\"p\", null, \"A big part of this was making sure that all my services were strictly available over HTTPS (via private subdomains of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://lachlan.io/\"\n  }, \"lachlan.io\"), \"). A tool like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://cert-manager.io/\"\n  }, \"cert-manager\"), \" can be used to automatically issue regular TLS certificates, but I wasn't satisfied with the fact that my internal domain names would be leaked via publicly available \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"certificate transparency logs\"), \".\"), mdx(\"p\", null, \"As an example, take a look at the logs for my domain: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://crt.sh/?q=lachlan.io\"\n  }, \"https://crt.sh/?q=lachlan.io\"), \". In that list, you'll see \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"home.lachlan.io\"), \", a certificate I initially issued for one of my internally hosted services. That record will remain publicly available \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"forever\"), \", leaking private information about which services I'm using. On the other hand, a wildcard certificate like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*.lachlan.io\"), \" leaks nothing more than the fact that I'm using any number of subdomains.\"), mdx(\"p\", null, \"In this post, I will describe how I used cert-manager to configure a default wildcard certificate for K3's inbuilt Traefik ingress controller.\"), mdx(\"blockquote\", {\n    style: {\n      \"background\": \"#fd01\",\n      \"borderLeftColor\": \"#fd0\",\n      \"padding\": \"1px 2rem\"\n    }\n  }, mdx(\"h5\", null, mdx(\"em\", null, \"Warning\")), mdx(\"p\", {\n    style: {\n      \"fontStyle\": \"normal\"\n    }\n  }, \"Careful consideration must be applied when using wildcard TLS certificates. If a server holding the private key for a wildcard certificate is compromised, then the confidentiality and integrity of \", mdx(\"em\", null, \"all\"), \" traffic to \", mdx(\"em\", null, \"all\"), \" other servers using the certificate will also be compromised. On the other hand, the compromise of a regular TLS certificate only affects the one subdomain, significantly lowering the blast radius of an event.\"), mdx(\"p\", {\n    style: {\n      \"fontStyle\": \"normal\"\n    }\n  }, \"As a general rule of thumb, you probably shouldn't be using a wildcard certificate unless you have one of the following requirements:\"), mdx(\"ol\", null, mdx(\"li\", null, \"You don't want your subdomains showing up in certificate transparency logs.\"), mdx(\"li\", null, \"You're issuing for so many subdomains that certificate providers are rate-limiting you.\"))), mdx(\"h2\", null, \"Preparing the Cluster\"), mdx(\"p\", null, \"Deploying the actual K3s cluster is out of the scope of this article, so please use the official \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://rancher.com/docs/k3s/latest/en/quick-start/\"\n  }, \"quick-start guide\"), \" if needed. Once your cluster is up and running, the first step will be to install cert-manager. You can do this by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kubectl\"), \" applying regular manifests, but I'm partial to using helm charts wherever possible:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"# Create the namespace for cert-manager\\nkubectl create namespace cert-manager\\n# Add the Jetstack Helm repository and update your local cache\\nhelm repo add jetstack https://charts.jetstack.io && helm repo update\\n# Install cert-manager with CRD resources\\nhelm install \\\\\\n  cert-manager jetstack/cert-manager \\\\\\n  --namespace cert-manager \\\\\\n  --version v1.2.0 \\\\\\n  --create-namespace \\\\\\n  --set installCRDs=true\\n\")), mdx(\"p\", null, \"Once it's finished, you should be able to run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kubectl get pods --namespace cert-manager\"), \" to check the cert-manager namespace for running pods.\"), mdx(\"h2\", null, \"Create a ClusterIssuer\"), mdx(\"p\", null, \"Now that cert-manager is up and running, we should start by creating a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ClusterIssuer\"), \". There are a multitude of different ways to configure it, so the best solution will depend on your specific requirements. In my case, I'm using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://cert-manager.io/docs/configuration/acme/\"\n  }, \"ACME issuer type\"), \" with DNS01 challenges via Cloudflare. This involves me first needing to get an API token from Cloudflare and then providing it to K3s as a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Secret\"), \" resource:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\",\n    \"metastring\": \"{8,17,23}\",\n    \"{8,17,23}\": true\n  }, \"apiVersion: v1\\nkind: Secret\\nmetadata:\\n  name: cloudflare-api-token\\n  namespace: cert-manager\\ntype: Opaque\\nstringData:\\n  api-token: REDACTED\\n---\\napiVersion: cert-manager.io/v1\\nkind: ClusterIssuer\\nmetadata:\\n  name: letsencrypt-prod\\nspec:\\n  acme:\\n    server: https://acme-v02.api.letsencrypt.org/directory\\n    email: REDACTED\\n    privateKeySecretRef:\\n      name: letsencrypt-prod-key\\n    solvers:\\n      - dns01:\\n          cloudflare:\\n            email: REDACTED\\n            apiTokenSecretRef:\\n              name: cloudflare-api-token-secret\\n              key: api-token\\n\")), mdx(\"p\", null, \"The above is fairly straightforward. Using a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ClusterIssuer\"), \" (over a standard \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Issuer\"), \") will make it possible to create the wildcard certificate in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kube-system\"), \" namespace that K3s uses for Traefik. Also, note that any referenced \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Secret\"), \" resources will (by default) need to be in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cert-manager\"), \" namespace.\"), mdx(\"h2\", null, \"Request a Wildcard Certificate\"), mdx(\"p\", null, \"Now comes the (arguably) fun part: certificate generation. Apply something like the following to get started:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\",\n    \"metastring\": \"{11}\",\n    \"{11}\": true\n  }, \"apiVersion: cert-manager.io/v1\\nkind: Certificate\\nmetadata:\\n  name: wildcard-lachlan-io\\n  namespace: kube-system\\nspec:\\n  secretName: wildcard-lachlan-io-tls\\n  issuerRef:\\n    name: letsencrypt-prod\\n    kind: ClusterIssuer\\n  dnsNames:\\n    - \\\"*.lachlan.io\\\"\\n\")), mdx(\"p\", null, \"You can follow along with the progress of the certificate request by using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kubectl describe certificate -n kube-system\"), \". Watch the events until you see the message \\\"certificate issued successfully.\\\" If you encounter any errors, this will also be the place to start investigating the issue.\"), mdx(\"h2\", null, \"Configure Traefik\"), mdx(\"p\", null, \"We're in the home stretch now. The final part is to reconfigure the default K3s Traefik installation so that it uses our shiny new wildcard certificate by default. When an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Ingress\"), \" resource is defined without a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec.tls.secretName\"), \", Traefik will attempt to use its configured default TLS certificate instead. If we mount our wildcard certificate in such a way that it overrides the one Traefik generates, we will effectively be setting it as the new default certificate. K3s makes it easy to do this since it is designed to automatically redeploy Traefik when any changes are made to its helm chart.\"), mdx(\"p\", null, \"In your text editor of choice, open up \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/var/lib/rancher/k3s/server/manifests/traefik.yaml\"), \" on your K3s server node and add the following to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec.valuesContent\"), \" string:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"extraVolumeMounts:\\n  - name: ssl\\n    mountPath: /ssl\\nextraVolumes:\\n  - name: ssl\\n    secret:\\n      secretName: wildcard-lachlan-io-tls\\n\")), mdx(\"p\", null, \"Since Traefik runs in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kube-system\"), \" namespace, it will easily pick up your wildcard secret, mount it, and use it as the new default certificate! At this point, you're now free to expose services by creating arbitrary ingress resources. As long as you don't specify \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"spec.tls.secretName\"), \", the wildcard certificate will be used:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"apiVersion: networking.k8s.io/v1\\nkind: Ingress\\nmetadata:\\n  name: home\\n  namespace: home\\n  annotations:\\n    kubernetes.io/ingress.class: traefik\\n    traefik.ingress.kubernetes.io/redirect-entry-point: https\\nspec:\\n  rules:\\n    - host: home.lachlan.io\\n      http:\\n        paths:\\n          - backend:\\n              service:\\n                name: home\\n                port:\\n                  number: 80\\n            path: /\\n            pathType: Prefix\\n  tls:\\n    - hosts:\\n        - home.lachlan.io\\n\")), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"960px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"49.583333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB0ElEQVQoz5WSTYtSURiA73LUVv6CCKL8yNEhdVKHaGxXMDlFwSBkTm1mtFkMwdBKQUVwoYIrwd8gCuJGwZXupr9Ro9dqHK/3Xj+euJekRptFLzy873s45+G8hyPcvnOXZy9e8zz0Bq//CU63ny3PDs6HPuxOD9uBIPesDsxmMwaDUWdjw4DRaMJkurWG4HJt4fF4sdseYLPasVpsWO5b2PY+Ync3SDD4FL8vgNvtxe324PMF2Nl5rPcOh5PNTdc1hLeRdxwchNnbC7G//0onFHpJJBIlFj8hHj/h6CjG8XGcWCzO6eknzs4+E4t9JBp9z+Hhh2sIs9mM+XzOamhr0+kUVVX1vERRFGRZ1mttzyoCN8RisUBR1N8SVRdrKOqfejKRGUsSkjRB0rOEoB1cRYurqzEDUeTrtwvE4Xcu+gMG4hBxOEQUh/T7A120nETL2llh9VZL4eVoRH8g0heHjKWJXmtCWVGZyDI/fl7+c7I14fI9O50OxWKRbrdLu92mXC7z5fycer1Oq9Wi2WxSq9WoVCp6X61WGY1GNwt7vR6pVIp8Pk8ymSSTydBoNEin0+RyObLZLKVSiUQiQTgcplAorN/wb/H/hPaG2m/RhL8A/YVy0yevcswAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"An internal service using a wildcard certificate.\",\n    \"title\": \"An internal service using a wildcard certificate.\",\n    \"src\": \"/static/7a76b555f81ddc086210878820f8d997/7d769/mission-complete.png\",\n    \"srcSet\": [\"/static/7a76b555f81ddc086210878820f8d997/5243c/mission-complete.png 240w\", \"/static/7a76b555f81ddc086210878820f8d997/ab158/mission-complete.png 480w\", \"/static/7a76b555f81ddc086210878820f8d997/7d769/mission-complete.png 960w\", \"/static/7a76b555f81ddc086210878820f8d997/da8b6/mission-complete.png 1000w\"],\n    \"sizes\": \"(max-width: 960px) 100vw, 960px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \")), mdx(\"p\", null, \"This prevents you from having to do any hacky secret copying/syncing across namespaces while providing the privacy benefits that wildcard certificates afford. I couldn't find a guide online that adequately explained how to cleanly manage a wildcard certificate in this fashion, so I hope this article is able to help you with your own projects (be them personal or professional).\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"K3s  is a lightweight Kubernetes distribution built for the purposes of IoT and Edge computing. Recently, I decided to use it as the basis…","timeToRead":3,"banner":{"childImageSharp":{"resize":{"src":"/static/b8bd2495a8ec3e6c47067cfe6ec2459f/a6c62/using-wildcard-certificates-with-traefik-and-k3s.jpg"}}}}},"pageContext":{"slug":"/blog/using-wildcard-certificates-with-traefik-and-k3s","formatString":"MMM Do YYYY"}},"staticQueryHashes":["2744905544","3090400250","318001574"]}